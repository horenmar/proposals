\documentclass{wg21}

\input{glyphtounicode}
\pdfgentounicode=1

\usepackage{xcolor}
\usepackage{soul}
\usepackage{ulem}
\usepackage{fullpage}
\usepackage{parskip}
\usepackage{csquotes}
\usepackage{relsize}      % provide relative font size changes
\usepackage{textcomp}     % provide \text{l,r}angle
\usepackage{mathrsfs}     % mathscr font
\usepackage{microtype}

\title{Make Random Number Engines Seedable}
\docnumber{D2060R0}
\audience{LEWG}
\author{Martin Hořeňovský}{martin.horenovsky@gmail.com}

\usepackage[inner=2cm,outer=2cm]{geometry}

\begin{document}
\maketitle


\hypertarget{introduction}{%
    \section{Introduction}\label{introduction}}

The C++ standard library provides a set of utilities, that is random
number engines, statistical distributions and seeding utilities, to
generate pseudo-random numbers with different properties. Unfortunately,
the current state of seeding random number engines is fundamentally
broken.


\hypertarget{motivation}{%
    \section{Motivation}\label{motivation}}

A random number engine as defined in the C++ standard can be seeded in
one of 2 ways:
\begin{itemize}
    \item via a single value of engine's \tcode{result_type}
    \item via a type that satisfies the \emph{SeedSequence} named requirement, such as \tcode{std::seed_seq}
\end{itemize}

The first option is commonly used together with \tcode{std::random_device}
to get a random number engine with random initial state, like so:

\begin{codeblock}
#include <iostream>
#include <random>

int main() {
    std::mt19937 urbg(std::random_device{}());
    std::cout << urbg() << '\n';
}
\end{codeblock}

This code works and \emph{should}\footnote{Assuming good implementation
of \tcode{random_device}} print out a different number every run. However,
there is a massive difference between the seed size, which is specified
to be \tcode{unsigned int} and thus 32 bits on most commonly used platforms,
and the size of a Mersenne Twister's internal state, which is 624 32-bit
unsigned integers.

A side effect of this kind of insufficiently large random seeding is that
if I tell you that the first number generated by \tcode{urbg} is
\(3046098682\)\footnote{Another interesting thing is that there are no
32 bit seeds that will give you 7 as the first output from \tcode{urbg}.
Also, 7 is not the only number with this property.},
you can quickly\footnote{It took about 10 minutes on my desktop PC}
find the seed and use it to predict all future outputs.

In theory, this can be fixed by using a \emph{SeedSequence},
such as the standard-provided \tcode{seed_seq}, but there are two
problems with this:

\begin{enumerate}

\item We have no way to know how much randomness we have to feed into
a \tcode{seed_seq} to initialize a specific engine, and

\item \tcode{seed_seq} is not a bijection even if you give it enough
randomness for target data storage

\end{enumerate}

The second problem can be \href{https://godbolt.org/z/-SCJCI}
{demonstrated with a simple example}\footnote{The values are borrowed
from a \href{http://www.pcg-random.org/posts/cpp-seeding-surprises.html}
{blogpost by Melissa E. O'Neill} of PCG}:

\begin{codeblock}
#include <array>
#include <iostream>
#include <random>

int main() {
    std::seed_seq seq1({0xf5e5b5c0, 0xdcb8e4b1}),
                  seq2({0xd34295df, 0xba15c4d0});

    std::array<uint32_t, 2> arr1, arr2;
    seq1.generate(arr1.begin(), arr1.end());
    seq2.generate(arr2.begin(), arr2.end());

    std::cout << (arr1 == arr2) << '\n';
}
\end{codeblock}

This code outputs \tcode{1}, which shows that two different instances
of \tcode{std::seed_seq}, given different 64 bits of seeding, generate
the same 64 bits of output.

These issues mean that properly seeding the Random Number Engines in
\tcode{<random>} is impossible, which should be fixed.


\hypertarget{proposed-solution}{%
    \section{Proposed solution}\label{proposed-solution}}

\hypertarget{solution-1-give-randomness-size}{%
    \subsection{User should be able to retrieve generator's seed size}
\label{solution-1-give-randomness-size}}

To solve the problem with the full size of a seed for a a random number
engine being unknowable, I propose adding a new requirement on a random
number engine in [rand.req.eng]. Specifically, a member function
\tcode{static constexpr size_t required_seed_size()} that returns the
number of bytes required to fully seed random number engine of that
type.


\hypertarget{solution-2-add-std-sequences}{%
    \subsection{Introduce new standard types that conform to the \emph{SeedSequence} requirements}
    \label{solution-2-add-std-sequences}}

To solve the problems with \tcode{std::seed_seq}, I propose adding new
type that conforms to the \emph{SeedSequence} requirement to the
standard library.

Specifically, I propose adding a type to the standard,
\tcode{sized_seed_seq}, whose \tcode{generate} member function writes
out the data exactly as they were passed to the instance during
construction. If the amount of data requested by user from
\tcode{generate} is less than the amount of data stored, only the first
\emph{n} bytes is written out. If the amount of data requested is larger,
the behaviour is undefined.

By combining the two changes above, we can now properly seed a random
number engine, such as \tcode{mt19337}, with random data, using code
like this:

\begin{codeblock}
#include <algorithm>
#include <array>
#include <iostream>
#include <random>

int main() {
    std::array<uint32_t, std::mt19337::required_seed_size()> random_data;
    std::generate(random_data.begin(), random_data.end(), std::random_device{});
    std::mt19937 urbg(std::sized_seed_seq(random_data.begin(), random_data.end()));
    std::cout << urbg() << '\n';
}
\end{codeblock}

However, while proper random seeding is now possible, the code is quite
long and clunky. Because randomly initializing a random number engine
is a common use case, I propose adding \tcode{generate} member function
to \tcode{random_device}, so it can be used as a \emph{SeedSequence}.
This would transform the code above into this:

\begin{codeblock}
#include <iostream>
#include <random>

int main() {
    std::mt19937 urbg(std::random_device{});
    std::cout << urbg() << '\n';
}
\end{codeblock}

With this change, it is easier to seed a random number engine with
random seed correctly, than it is to seed it incorrectly. However,
\tcode{random_device} does not, and can not, fulfill the
\emph{SeedSequence} requirements. Because of this I also suggest refining
the requirements in the next part.


\hypertarget{solution-3-different-requirement}{%
    \subsection{Refine \emph{SeedSequence} requirement}
\label{solution-3-different-requirement}}

To allow for the type \tcode{std::random_seed_seq} to integrate with
the rest of the random facilities properly, I propose renaming the
\emph{SeedSequence} named requirement to \emph{RepeatableSeedSeq}, and
introducing a weaker requirement using the old name of \emph{SeedSequence}.
This weaker requirement no longer includes the \tcode{size} and the
\tcode{param} member functions, and also removes the repeatability
requirements on \tcode{generate} called with the same arguments.


\hypertarget{alternative-approach}{%
    \section{Alternative approach}\label{alternative-approach}}

An alternative approach to changing \tcode{std::random_device} to act
as a \emph{SeedSequence} is to introduce new type, named
\tcode{random_seed_seq}, and have it serve as a \emph{SeedSequence}
whose \tcode{generate} writes out high-quality random bits.

\hypertarget{goals}{%
    \section{Goals}\label{goals}}

To recapitulate, this paper has three goals:
\begin{enumerate}
    \item Make it possible for generic code to determine how big a seed
    does a random number engine require.
    \item Add a new type satisfying the requirements of \emph{SeedSequence}
    to the standard library, one that avoids some of the problems with
    \tcode{std::seed_seq}.
    \item Improve the usability of seeding by adding a \emph{SeedSequence}
    type that seeds with high-quality random bits, sacrificing
    repeatability.
\end{enumerate}


\hypertarget{acknowledgments}{
\section{Acknowledgments}
\label{acknowledgments}}

I want to thank Melissa E. O'Neill whose work I drew upon for this paper.


\end{document}
